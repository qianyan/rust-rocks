use std::mem::{align_of, size_of};

struct S1 {
    a: u8,
    b: u16,
    c: u8,
}

struct S2 {
    a: u8,
    c: u8,
    b: u16,
}

fn main() {
    println!("sizeof S1: {}, S2: {}", size_of::<S1>(), size_of::<S2>());
    println!("alig_of S1: {}, S2: {}", align_of::<S1>(), align_of::<S2>());
}

// 对比 size.c 中的出现了的 S1: 6, S2: 4
// 可以发现 rust 对此做了优化
// 为了避免数据不对齐造成的 cpu 多次访问 mem 的性能损耗，所以需要在语言编译器层面进行优化
// 优化规则如下，原理暂时不明确，不过例子很清楚：
// 1. 结构体中的每个字段的长度和对齐长度要一致。如u8的长度是1字节，所以对齐长度也必须是1。
// 2. 每个字段的起始地址也要和自身的对齐长度对齐，也就是起始地址是自身对齐长度的整数倍。
// 3. 结构体的对齐大小和最大字段的对齐大小相同，结构体的长度是对齐长度的整数倍。
